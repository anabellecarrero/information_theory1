# information_theory1
Compression Assigments and Library for the Introduction to Theory Course took at the Federal University of Para√≠ba.

Project description:

This project was divided into two sections:
This project's idea is based on a compressor/decompressor implementation utilizing the LZW algorithm (which was seen in class) with an arithmetic coding. Taking under advisement that the messages were generated by sources that have alphabet A = {0, 1,...,255}, the compressor/decompressor was tested on a binary video file (disco.mp4) and a 16-MB Portuguese corpus text (corpus16MB.txt).

There were various tests with different maximum dictionary sizes, and this maximum must be 2*(K), where should range between 9 and 16. It's important to clarify that K indicates the number of bits in which each dictionary index that needs to be stored. 

Example: K = 9 bits, dictionary size: 2*(9) = 512

Notes:
The test file's symbols should be read in binary mode (numbers), not text mode (strings or characters).
It must be a numeric symbol dictionary, not a character one.
While the coder requires a file as input and generate a coded file as output, the decoder needs a coded file as an input and generate a decoded file as an output, exactly like the original one.

The function criar_graficos is responsible for plotting three graphs:
1- (Processing Time X K), for K = 9, 10, 11, 12, 13, 14, 15,  16. The K variant should be on graphs's X axle.
2- (RC X K), which RC stands for an equation that represents:
RC = tamArqOriginal / tamArqComprimido (OriginalFileSize / CompressedFileSize)
3- (RC X K), which RC stands for an equation that represents:
RC = tamArqOriginal/ ((totalIndices X K)/8) (OriginalFileSize / (TotalIndex X K)8))
TotalIndex = index's total amount used during the message encoding.

